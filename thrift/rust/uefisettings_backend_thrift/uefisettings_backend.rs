// @generated by Thrift for thrift/uefisettings_backend.thrift
// This file is probably not the place you want to edit!

#![recursion_limit = "100000000"]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused_crate_dependencies)]

pub use self::types::*;

/// Thrift type definitions for `uefisettings_backend`.
pub mod types {
    #![allow(clippy::redundant_closure)]


    #[derive(Clone, PartialEq)]
    pub struct MachineInfo {
        pub backend: ::std::collections::BTreeSet<crate::types::Backend>,
        pub bios_vendor: ::std::string::String,
        pub bios_version: ::std::string::String,
        pub bios_release: ::std::string::String,
        pub bios_date: ::std::string::String,
        pub product_name: ::std::string::String,
        pub product_family: ::std::string::String,
        pub product_version: ::std::string::String,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct Question {
        pub name: ::std::string::String,
        pub answer: ::std::string::String,
        pub options: ::std::vec::Vec<::std::string::String>,
        pub help: ::std::string::String,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq)]
    pub struct SetResponse {
        pub selector: ::std::string::String,
        pub backend: crate::types::Backend,
        pub question: crate::types::Question,
        pub modified: ::std::primitive::bool,
        pub is_translated: ::std::primitive::bool,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq)]
    pub struct SetResponseList {
        pub responses: ::std::vec::Vec<crate::types::SetResponse>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq)]
    pub struct GetResponse {
        pub selector: ::std::string::String,
        pub backend: crate::types::Backend,
        pub question: crate::types::Question,
        pub is_translated: ::std::primitive::bool,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq)]
    pub struct GetResponseList {
        pub responses: ::std::vec::Vec<crate::types::GetResponse>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct Error {
        pub error_message: ::std::string::String,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq)]
    pub struct IloAttributes {
        pub selector: ::std::string::String,
        pub attributes: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct HiiShowIfrResponse {
        pub readable_representation: ::std::string::String,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct HiiDatabase {
        pub db: ::std::vec::Vec<::std::primitive::u8>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq)]
    pub struct HiiStringsPackage {
        pub package_list: ::std::string::String,
        pub string_package: ::std::collections::BTreeMap<::std::primitive::i32, ::std::string::String>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct Backend(pub ::std::primitive::i32);

    impl Backend {
        pub const Unknown: Self = Backend(0i32);
        pub const Hii: Self = Backend(1i32);
        pub const Ilo: Self = Backend(2i32);
    }

    impl ::fbthrift::ThriftEnum for Backend {
        fn enumerate() -> &'static [(Backend, &'static str)] {
            &[
                (Backend::Unknown, "Unknown"),
                (Backend::Hii, "Hii"),
                (Backend::Ilo, "Ilo"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "Unknown",
                "Hii",
                "Ilo",
            ]
        }

        fn variant_values() -> &'static [Backend] {
            &[
                Backend::Unknown,
                Backend::Hii,
                Backend::Ilo,
            ]
        }
    }

    impl ::std::default::Default for Backend {
        fn default() -> Self {
            Backend(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a Backend> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a Backend) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<Backend> for ::std::primitive::i32 {
        #[inline]
        fn from(x: Backend) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for Backend {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for Backend {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("Unknown", 0),
                ("Hii", 1),
                ("Ilo", 2),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for Backend {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "Backend::{}", self)
        }
    }

    impl ::std::str::FromStr for Backend {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("Hii", 1),
                ("Ilo", 2),
                ("Unknown", 0),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "Backend").map(Backend)
        }
    }

    impl ::fbthrift::GetTType for Backend {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for Backend
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for Backend
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(Backend::from(p.read_i32()?))
        }
    }

    impl ::std::default::Default for self::MachineInfo {
        fn default() -> Self {
            Self {
                backend: ::std::default::Default::default(),
                bios_vendor: ::std::default::Default::default(),
                bios_version: ::std::default::Default::default(),
                bios_release: ::std::default::Default::default(),
                bios_date: ::std::default::Default::default(),
                product_name: ::std::default::Default::default(),
                product_family: ::std::default::Default::default(),
                product_version: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::MachineInfo {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("MachineInfo")
                .field("backend", &self.backend)
                .field("bios_vendor", &self.bios_vendor)
                .field("bios_version", &self.bios_version)
                .field("bios_release", &self.bios_release)
                .field("bios_date", &self.bios_date)
                .field("product_name", &self.product_name)
                .field("product_family", &self.product_family)
                .field("product_version", &self.product_version)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::MachineInfo {}
    unsafe impl ::std::marker::Sync for self::MachineInfo {}

    impl ::fbthrift::GetTType for self::MachineInfo {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::MachineInfo
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("MachineInfo");
            p.write_field_begin("backend", ::fbthrift::TType::Set, 1);
            ::fbthrift::Serialize::write(&self.backend, p);
            p.write_field_end();
            p.write_field_begin("bios_vendor", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.bios_vendor, p);
            p.write_field_end();
            p.write_field_begin("bios_version", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.bios_version, p);
            p.write_field_end();
            p.write_field_begin("bios_release", ::fbthrift::TType::String, 4);
            ::fbthrift::Serialize::write(&self.bios_release, p);
            p.write_field_end();
            p.write_field_begin("bios_date", ::fbthrift::TType::String, 5);
            ::fbthrift::Serialize::write(&self.bios_date, p);
            p.write_field_end();
            p.write_field_begin("product_name", ::fbthrift::TType::String, 6);
            ::fbthrift::Serialize::write(&self.product_name, p);
            p.write_field_end();
            p.write_field_begin("product_family", ::fbthrift::TType::String, 7);
            ::fbthrift::Serialize::write(&self.product_family, p);
            p.write_field_end();
            p.write_field_begin("product_version", ::fbthrift::TType::String, 8);
            ::fbthrift::Serialize::write(&self.product_version, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::MachineInfo
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("backend", ::fbthrift::TType::Set, 1),
                ::fbthrift::Field::new("bios_date", ::fbthrift::TType::String, 5),
                ::fbthrift::Field::new("bios_release", ::fbthrift::TType::String, 4),
                ::fbthrift::Field::new("bios_vendor", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("bios_version", ::fbthrift::TType::String, 3),
                ::fbthrift::Field::new("product_family", ::fbthrift::TType::String, 7),
                ::fbthrift::Field::new("product_name", ::fbthrift::TType::String, 6),
                ::fbthrift::Field::new("product_version", ::fbthrift::TType::String, 8),
            ];
            let mut field_backend = ::std::option::Option::None;
            let mut field_bios_vendor = ::std::option::Option::None;
            let mut field_bios_version = ::std::option::Option::None;
            let mut field_bios_release = ::std::option::Option::None;
            let mut field_bios_date = ::std::option::Option::None;
            let mut field_product_name = ::std::option::Option::None;
            let mut field_product_family = ::std::option::Option::None;
            let mut field_product_version = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Set, 1) => field_backend = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_bios_vendor = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_bios_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 4) => field_bios_release = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 5) => field_bios_date = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 6) => field_product_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 7) => field_product_family = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 8) => field_product_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                backend: field_backend.unwrap_or_default(),
                bios_vendor: field_bios_vendor.unwrap_or_default(),
                bios_version: field_bios_version.unwrap_or_default(),
                bios_release: field_bios_release.unwrap_or_default(),
                bios_date: field_bios_date.unwrap_or_default(),
                product_name: field_product_name.unwrap_or_default(),
                product_family: field_product_family.unwrap_or_default(),
                product_version: field_product_version.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::Question {
        fn default() -> Self {
            Self {
                name: ::std::default::Default::default(),
                answer: ::std::default::Default::default(),
                options: ::std::default::Default::default(),
                help: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::Question {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("Question")
                .field("name", &self.name)
                .field("answer", &self.answer)
                .field("options", &self.options)
                .field("help", &self.help)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::Question {}
    unsafe impl ::std::marker::Sync for self::Question {}

    impl ::fbthrift::GetTType for self::Question {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Question
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Question");
            p.write_field_begin("name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_begin("answer", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.answer, p);
            p.write_field_end();
            p.write_field_begin("options", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.options, p);
            p.write_field_end();
            p.write_field_begin("help", ::fbthrift::TType::String, 4);
            ::fbthrift::Serialize::write(&self.help, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Question
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("answer", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("help", ::fbthrift::TType::String, 4),
                ::fbthrift::Field::new("name", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("options", ::fbthrift::TType::List, 3),
            ];
            let mut field_name = ::std::option::Option::None;
            let mut field_answer = ::std::option::Option::None;
            let mut field_options = ::std::option::Option::None;
            let mut field_help = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_answer = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_options = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 4) => field_help = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                name: field_name.unwrap_or_default(),
                answer: field_answer.unwrap_or_default(),
                options: field_options.unwrap_or_default(),
                help: field_help.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::SetResponse {
        fn default() -> Self {
            Self {
                selector: ::std::default::Default::default(),
                backend: ::std::default::Default::default(),
                question: ::std::default::Default::default(),
                modified: ::std::default::Default::default(),
                is_translated: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::SetResponse {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("SetResponse")
                .field("selector", &self.selector)
                .field("backend", &self.backend)
                .field("question", &self.question)
                .field("modified", &self.modified)
                .field("is_translated", &self.is_translated)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::SetResponse {}
    unsafe impl ::std::marker::Sync for self::SetResponse {}

    impl ::fbthrift::GetTType for self::SetResponse {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::SetResponse
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("SetResponse");
            p.write_field_begin("selector", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.selector, p);
            p.write_field_end();
            p.write_field_begin("backend", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.backend, p);
            p.write_field_end();
            p.write_field_begin("question", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.question, p);
            p.write_field_end();
            p.write_field_begin("modified", ::fbthrift::TType::Bool, 4);
            ::fbthrift::Serialize::write(&self.modified, p);
            p.write_field_end();
            p.write_field_begin("is_translated", ::fbthrift::TType::Bool, 5);
            ::fbthrift::Serialize::write(&self.is_translated, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::SetResponse
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("backend", ::fbthrift::TType::I32, 2),
                ::fbthrift::Field::new("is_translated", ::fbthrift::TType::Bool, 5),
                ::fbthrift::Field::new("modified", ::fbthrift::TType::Bool, 4),
                ::fbthrift::Field::new("question", ::fbthrift::TType::Struct, 3),
                ::fbthrift::Field::new("selector", ::fbthrift::TType::String, 1),
            ];
            let mut field_selector = ::std::option::Option::None;
            let mut field_backend = ::std::option::Option::None;
            let mut field_question = ::std::option::Option::None;
            let mut field_modified = ::std::option::Option::None;
            let mut field_is_translated = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_selector = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_backend = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_question = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 4) => field_modified = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 5) => field_is_translated = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                selector: field_selector.unwrap_or_default(),
                backend: field_backend.unwrap_or_default(),
                question: field_question.unwrap_or_default(),
                modified: field_modified.unwrap_or_default(),
                is_translated: field_is_translated.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::SetResponseList {
        fn default() -> Self {
            Self {
                responses: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::SetResponseList {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("SetResponseList")
                .field("responses", &self.responses)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::SetResponseList {}
    unsafe impl ::std::marker::Sync for self::SetResponseList {}

    impl ::fbthrift::GetTType for self::SetResponseList {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::SetResponseList
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("SetResponseList");
            p.write_field_begin("responses", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(&self.responses, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::SetResponseList
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("responses", ::fbthrift::TType::List, 1),
            ];
            let mut field_responses = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::List, 1) => field_responses = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                responses: field_responses.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::GetResponse {
        fn default() -> Self {
            Self {
                selector: ::std::default::Default::default(),
                backend: ::std::default::Default::default(),
                question: ::std::default::Default::default(),
                is_translated: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::GetResponse {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("GetResponse")
                .field("selector", &self.selector)
                .field("backend", &self.backend)
                .field("question", &self.question)
                .field("is_translated", &self.is_translated)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::GetResponse {}
    unsafe impl ::std::marker::Sync for self::GetResponse {}

    impl ::fbthrift::GetTType for self::GetResponse {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetResponse
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetResponse");
            p.write_field_begin("selector", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.selector, p);
            p.write_field_end();
            p.write_field_begin("backend", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.backend, p);
            p.write_field_end();
            p.write_field_begin("question", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.question, p);
            p.write_field_end();
            p.write_field_begin("is_translated", ::fbthrift::TType::Bool, 4);
            ::fbthrift::Serialize::write(&self.is_translated, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetResponse
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("backend", ::fbthrift::TType::I32, 2),
                ::fbthrift::Field::new("is_translated", ::fbthrift::TType::Bool, 4),
                ::fbthrift::Field::new("question", ::fbthrift::TType::Struct, 3),
                ::fbthrift::Field::new("selector", ::fbthrift::TType::String, 1),
            ];
            let mut field_selector = ::std::option::Option::None;
            let mut field_backend = ::std::option::Option::None;
            let mut field_question = ::std::option::Option::None;
            let mut field_is_translated = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_selector = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_backend = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_question = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 4) => field_is_translated = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                selector: field_selector.unwrap_or_default(),
                backend: field_backend.unwrap_or_default(),
                question: field_question.unwrap_or_default(),
                is_translated: field_is_translated.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::GetResponseList {
        fn default() -> Self {
            Self {
                responses: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::GetResponseList {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("GetResponseList")
                .field("responses", &self.responses)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::GetResponseList {}
    unsafe impl ::std::marker::Sync for self::GetResponseList {}

    impl ::fbthrift::GetTType for self::GetResponseList {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetResponseList
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetResponseList");
            p.write_field_begin("responses", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(&self.responses, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetResponseList
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("responses", ::fbthrift::TType::List, 1),
            ];
            let mut field_responses = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::List, 1) => field_responses = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                responses: field_responses.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::Error {
        fn default() -> Self {
            Self {
                error_message: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::Error {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("Error")
                .field("error_message", &self.error_message)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::Error {}
    unsafe impl ::std::marker::Sync for self::Error {}

    impl ::fbthrift::GetTType for self::Error {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Error
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Error");
            p.write_field_begin("error_message", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.error_message, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Error
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("error_message", ::fbthrift::TType::String, 1),
            ];
            let mut field_error_message = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_error_message = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                error_message: field_error_message.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::IloAttributes {
        fn default() -> Self {
            Self {
                selector: ::std::default::Default::default(),
                attributes: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::IloAttributes {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("IloAttributes")
                .field("selector", &self.selector)
                .field("attributes", &self.attributes)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::IloAttributes {}
    unsafe impl ::std::marker::Sync for self::IloAttributes {}

    impl ::fbthrift::GetTType for self::IloAttributes {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::IloAttributes
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("IloAttributes");
            p.write_field_begin("selector", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.selector, p);
            p.write_field_end();
            p.write_field_begin("attributes", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.attributes, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::IloAttributes
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("attributes", ::fbthrift::TType::Map, 2),
                ::fbthrift::Field::new("selector", ::fbthrift::TType::String, 1),
            ];
            let mut field_selector = ::std::option::Option::None;
            let mut field_attributes = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_selector = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_attributes = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                selector: field_selector.unwrap_or_default(),
                attributes: field_attributes.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::HiiShowIfrResponse {
        fn default() -> Self {
            Self {
                readable_representation: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::HiiShowIfrResponse {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("HiiShowIfrResponse")
                .field("readable_representation", &self.readable_representation)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::HiiShowIfrResponse {}
    unsafe impl ::std::marker::Sync for self::HiiShowIfrResponse {}

    impl ::fbthrift::GetTType for self::HiiShowIfrResponse {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::HiiShowIfrResponse
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("HiiShowIfrResponse");
            p.write_field_begin("readable_representation", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.readable_representation, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::HiiShowIfrResponse
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("readable_representation", ::fbthrift::TType::String, 1),
            ];
            let mut field_readable_representation = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_readable_representation = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                readable_representation: field_readable_representation.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::HiiDatabase {
        fn default() -> Self {
            Self {
                db: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::HiiDatabase {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("HiiDatabase")
                .field("db", &self.db)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::HiiDatabase {}
    unsafe impl ::std::marker::Sync for self::HiiDatabase {}

    impl ::fbthrift::GetTType for self::HiiDatabase {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::HiiDatabase
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("HiiDatabase");
            p.write_field_begin("db", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.db, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::HiiDatabase
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("db", ::fbthrift::TType::String, 1),
            ];
            let mut field_db = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_db = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                db: field_db.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::HiiStringsPackage {
        fn default() -> Self {
            Self {
                package_list: ::std::default::Default::default(),
                string_package: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::HiiStringsPackage {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("HiiStringsPackage")
                .field("package_list", &self.package_list)
                .field("string_package", &self.string_package)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::HiiStringsPackage {}
    unsafe impl ::std::marker::Sync for self::HiiStringsPackage {}

    impl ::fbthrift::GetTType for self::HiiStringsPackage {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::HiiStringsPackage
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("HiiStringsPackage");
            p.write_field_begin("package_list", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.package_list, p);
            p.write_field_end();
            p.write_field_begin("string_package", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.string_package, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::HiiStringsPackage
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("package_list", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("string_package", ::fbthrift::TType::Map, 2),
            ];
            let mut field_package_list = ::std::option::Option::None;
            let mut field_string_package = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_package_list = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_string_package = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                package_list: field_package_list.unwrap_or_default(),
                string_package: field_string_package.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    mod dot_dot {
        #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
        pub struct OtherFields(pub(crate) ());

        #[allow(dead_code)] // if serde isn't being used
        pub(super) fn default_for_serde_deserialize() -> OtherFields {
            OtherFields(())
        }
    }
}

/// Error return types.
pub mod errors {
}
